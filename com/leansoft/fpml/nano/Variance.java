// Generated by xsd compiler for android/java
// DO NOT CHANGE!
package com.leansoft.fpml.nano;

import java.io.Serializable;
import com.leansoft.nano.annotation.*;
import java.math.BigDecimal;

/**
 * A type describing the variance amount of a variance swap
 */
public class Variance extends CalculationFromObservation implements Serializable {

    private static final long serialVersionUID = -1L;

	@Element
	private Money varianceAmount;
	
	@Element
	private BigDecimal volatilityStrikePrice;
	
	@Element
	private BigDecimal varianceStrikePrice;
	
	@Element
	private Boolean varianceCap;
	
	@Element
	private BigDecimal unadjustedVarianceCap;
	
	@Element
	private BoundedVariance boundedVariance;
	
	@Element
	private ExchangeTradedContract exchangeTradedContractNearest;
	
	@Element
	private BigDecimal vegaNotionalAmount;
	
    
	/**
     * public getter
     *
     * Variance amount, which is a cash multiplier.
     *
     * @returns com.leansoft.fpml.nano.Money
	 */
	public Money getVarianceAmount() {
	    return this.varianceAmount;
	}
	
	/**
	 * public setter
	 *
     * Variance amount, which is a cash multiplier.
     *
     * @param com.leansoft.fpml.nano.Money
	 */
	public void setVarianceAmount(Money varianceAmount) {
	    this.varianceAmount = varianceAmount;
	}
	/**
	 * public getter
	 *
     * @returns java.math.BigDecimal
	 */
	public BigDecimal getVolatilityStrikePrice() {
	    return this.volatilityStrikePrice;
	}
	
	/**
	 * public setter
	 *
     * @param java.math.BigDecimal
	 */
	public void setVolatilityStrikePrice(BigDecimal volatilityStrikePrice) {
	    this.volatilityStrikePrice = volatilityStrikePrice;
	}
	/**
	 * public getter
	 *
     * @returns java.math.BigDecimal
	 */
	public BigDecimal getVarianceStrikePrice() {
	    return this.varianceStrikePrice;
	}
	
	/**
	 * public setter
	 *
     * @param java.math.BigDecimal
	 */
	public void setVarianceStrikePrice(BigDecimal varianceStrikePrice) {
	    this.varianceStrikePrice = varianceStrikePrice;
	}
	/**
     * public getter
     *
     * If present and true, then variance cap is applicable.
     *
     * @returns java.lang.Boolean
	 */
	public Boolean getVarianceCap() {
	    return this.varianceCap;
	}
	
	/**
	 * public setter
	 *
     * If present and true, then variance cap is applicable.
     *
     * @param java.lang.Boolean
	 */
	public void setVarianceCap(Boolean varianceCap) {
	    this.varianceCap = varianceCap;
	}
	/**
     * public getter
     *
     * For use when varianceCap is applicable. Contains the scaling factor of the Variance Cap that can differ on a trade-by-trade basis in the European market. For example, a Variance Cap of 2.5^2 x Variance Strike Price has an unadjustedVarianceCap of 2.5.
     *
     * @returns java.math.BigDecimal
	 */
	public BigDecimal getUnadjustedVarianceCap() {
	    return this.unadjustedVarianceCap;
	}
	
	/**
	 * public setter
	 *
     * For use when varianceCap is applicable. Contains the scaling factor of the Variance Cap that can differ on a trade-by-trade basis in the European market. For example, a Variance Cap of 2.5^2 x Variance Strike Price has an unadjustedVarianceCap of 2.5.
     *
     * @param java.math.BigDecimal
	 */
	public void setUnadjustedVarianceCap(BigDecimal unadjustedVarianceCap) {
	    this.unadjustedVarianceCap = unadjustedVarianceCap;
	}
	/**
     * public getter
     *
     * Conditions which bound variance. The contract specifies one or more boundary levels. These levels are expressed as prices for confirmation purposes Underlyer price must be equal to or higher than Lower Barrier is known as Up Conditional Swap Underlyer price must be equal to or lower than Upper Barrier is known as Down Conditional Swap Underlyer price must be equal to or higher than Lower Barrier and must be equal to or lower than Upper Barrier is known as Barrier Conditional Swap.
     *
     * @returns com.leansoft.fpml.nano.BoundedVariance
	 */
	public BoundedVariance getBoundedVariance() {
	    return this.boundedVariance;
	}
	
	/**
	 * public setter
	 *
     * Conditions which bound variance. The contract specifies one or more boundary levels. These levels are expressed as prices for confirmation purposes Underlyer price must be equal to or higher than Lower Barrier is known as Up Conditional Swap Underlyer price must be equal to or lower than Upper Barrier is known as Down Conditional Swap Underlyer price must be equal to or higher than Lower Barrier and must be equal to or lower than Upper Barrier is known as Barrier Conditional Swap.
     *
     * @param com.leansoft.fpml.nano.BoundedVariance
	 */
	public void setBoundedVariance(BoundedVariance boundedVariance) {
	    this.boundedVariance = boundedVariance;
	}
	/**
     * public getter
     *
     * Specification of the exchange traded contract nearest.
     *
     * @returns com.leansoft.fpml.nano.ExchangeTradedContract
	 */
	public ExchangeTradedContract getExchangeTradedContractNearest() {
	    return this.exchangeTradedContractNearest;
	}
	
	/**
	 * public setter
	 *
     * Specification of the exchange traded contract nearest.
     *
     * @param com.leansoft.fpml.nano.ExchangeTradedContract
	 */
	public void setExchangeTradedContractNearest(ExchangeTradedContract exchangeTradedContractNearest) {
	    this.exchangeTradedContractNearest = exchangeTradedContractNearest;
	}
	/**
     * public getter
     *
     * Vega Notional represents the approximate gain/loss at maturity for a 1% difference between RVol (realised vol) and KVol (strike vol). It does not necessarily represent the Vega Risk of the trade.
     *
     * @returns java.math.BigDecimal
	 */
	public BigDecimal getVegaNotionalAmount() {
	    return this.vegaNotionalAmount;
	}
	
	/**
	 * public setter
	 *
     * Vega Notional represents the approximate gain/loss at maturity for a 1% difference between RVol (realised vol) and KVol (strike vol). It does not necessarily represent the Vega Risk of the trade.
     *
     * @param java.math.BigDecimal
	 */
	public void setVegaNotionalAmount(BigDecimal vegaNotionalAmount) {
	    this.vegaNotionalAmount = vegaNotionalAmount;
	}

}